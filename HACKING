This is a POD file. If you prefer reading a man page, run `perldoc ./HACKING`.
Or use `pod2text HACKING` to generate an easier to read text file. Both of
these programs should come with a default Perl installation.



=head1 DEBUGGING

=head2 Known issues

If you experience random crashes while using ncdc, try setting the I<tls_policy>
setting to I<disabled>. If this gets rid of the crashes, then most likely you're
hit by bugs in glib-networking:
L<#659821|https://bugzilla.gnome.org/show_bug.cgi?id=659821> and
L<#660252|https://bugzilla.gnome.org/show_bug.cgi?id=660252>.


=head2 General

Any debugging messages are written to C<~/.ncdc/stderr.log>. Note that this
file is emptied every time ncdc starts up, so be sure to either make backups or
check the contents of the log file before this happens!

Messages starting with C<CRITICAL> almost always indicate a bug. If you find
one, please report it! Messages starting with C<WARNING> can happen both
because something unexpected happened or because of a bug. If you see such a
message along the lines of "assertion failure" or "line should not be reached",
then this always indicates a bug.

By default, debug-level messages are not logged, enable the I<log_debug> setting
within ncdc to get these as well. Be warned, however, that depending on how you
use ncdc, this may generate a lot of data. My ncdc generates about 1 GiB per
week, for instance.


=head2 GDB

GDB can be used to debug various kinds of crashes (but not all of them),
deadlocks or to find out exactly when a C<CRITICAL> or C<WARNING> message is
being logged.  Note that you usually want ncdc to be compiled with debugging
symbols when using GDB. Compile as follows:

  ./configure CFLAGS=-g && make clean && make

How you run gdb depends on the kind of problem you are experiencing. Here are
some tips for various situations:

=over

=item ncdc crashes shortly after startup.

The easiest way is to just start ncdc within gdb directly.

  $ gdb /path/to/ncdc
  [..]
  > run

=item ncdc crashes after I perform a certain action.

Running ncdc within gdb as above is in that case not very optimal, since the
gdb messages may garble the screen and make it annoying to use ncdc. In this
case it's easier attach gdb to a running ncdc. To do so, run ncdc as you
usually would, and then run the following in a different terminal:

  $ gdb /path/to/ncdc $ncdc_pid
  [..]
  > continue

=item ncdc crashes randomly after a long period of time.

In this case it may be easier to use core dumps, as follows:

  $ ulimit -c unlimited
  $ ncdc  # run ncdc as you usually would
  [let it crash]
  $ gdb /path/to/ncdc core

=back

The above tips work nice for debugging crashes, but gdb can also be used to
debug when a C<WARNING> or C<CRITICAL> message is logged. Run ncdc with the
I<G_DEBUG> environment variable set to either I<fatal-criticals> or
I<fatal-warnings>. For example, the following will let ncdc crash as soon as a
C<WARNING> message is logged.

  $ G_DEBUG=fatal-warnings /path/to/ncdc

If you happened to get gdb to see the crash, then you can use gdb commands to
fetch more information on the crash. There are many online resources on
debugging using gdb, but here are a few important commands:

=over

=item bt

Get a backtrace.

=item info threads

List the active threads.

=item thread $number

Switch to another thread.

=back

In the off chance that you happened to have found a deadlock, these are easiest
to debug by attaching gdb to a deadlocked ncdc. Running ncdc within gdb or
using core dumps isn't very useful in these situations.


=head2 Valgrind

Valgrind can be used to debug crashes for which GDB fails. Bugs caused by
incorrect handling of memory are very easily detected with valgrind. A major
downside, however, is that ncdc takes approximately 10 times as much memory and
is 10 times slower than when run natively or in GDB. As with GDB, make sure you
have ncdc compiled with debugging symbols. To run ncdc in valgrind, use the
following command:

  $ G_DEBUG=gc-friendly G_SLICE=always-malloc valgrind --leak-check=full\
      --num-callers=25 --log-file=valgrindlog /path/to/ncdc

And any issue valgrind can find will be written to the file 'valgrindlog'. Note
that some of the reported problems, especially memory leaks, may not
necessarily come from ncdc itself, but are harmless issues within glib or other
libraries.

The following is an attempt at a simple valgrind suppression file, save this to
a file and add the C<--suppressions=$file> argument to the valgrind command in
order to use it. These suppressions don't cover everything, but will
significantly reduce the amount of problems reported. Hopefully they aren't so
general that they might masquerade actual bugs. Note that these suppressions
may require that your glib library has also been compiled with debugging
symbols.

  {
    init keeps memory around
    Memcheck:Leak
    ...
    fun:g_type_init_with_debug_flags
  }
  {
    interfaces are registered dynamically and never freed
    Memcheck:Leak
    ...
    fun:g_type_add_interface_static
  }
  {
    same for types
    Memcheck:Leak
    ...
    fun:g_type_register_static
  }
  {
    class initializations are kept around
    Memcheck:Leak
    ...
    fun:type_class_init_Wm
  }

If you see a lot of error reports about overlapping memory regions passed to
C<memcpy()>, then you're probably running a too old version of valgrind with a
too new version of libc. You can either upgrade valgrind or add the following
to your suppression file:

  {
    Valgrind thinks memmove() is a memcpy()
    Memcheck:Overlap
    fun:memcpy
  }





=head1 IDENTIFIERS

Ncdc uses all kinds of identifiers internally, let's explain some of them.

=over

=item hubid

A "hub id" is 64bit integer that uniquely identifies a hub. The number is
randomly generated and assigned upon the first run of </open> for a hub with
that name. The use of hub IDs allow a user to change the name of a hub tab
without compromising any other IDs or related configuration.

=item CID / PID

These are defined in the ADC spec. A CID uniquely identifies a user across
multiple hubs, but only works on the ADC protocol. Ncdc doesn't try to assign a
CID to users on NMDC hubs.

=item uid

A user id, internal to ncdc. This uniquely identifies a single user on a single
hub. It's a 64bit unsigned integer, generated by taking the first 8 bytes of a
tiger hash. The data that is hashed depends on the protocol, for ADC it's
C<tiger(hubid | cid)>, where C<cid> is the base32-encoded CID of the user. For
NMDC, it's C<tiger(hubid | name)>, where C<name> is the name of the user as
sent by the hub (thus in the encoding that the hub uses). In both cases, the
byte representation of <hubid> is hashed, so these IDs are dependent on the
byte order of the CPU architecture.

This ID is used everywhere where a user should be identified, and is also
stored on disk in the database file (in the download queue) and are used as the
filename for user file lists in the C<fl/> directory. They are usually
represented in ASCII as 16-character HEX values.

=back






=head1 SQLITE SCHEMA

This is the SQL schema used to store stuff in the db.sqlite3 file.  C<PRAGMA
user_version> is set to 1. Note that this schema does not include foreign key
clauses or other checks, in order to improve portability with older SQLite
versions.

=head2 Config & variables

  CREATE TABLE vars (
    name TEXT NOT NULL,
    hub INTEGER NOT NULL DEFAULT 0,
    value TEXT NOT NULL,
    PRIMARY KEY(name, hub)
  );

Stores key-value pairs for configuration data and various other variables that
need to be kept around for more than a single run. For global variables, C<hub>
is 0. For hub-local variables, C<hub> is a random 64-bit integer. It is treated
as unsigned in the code, but stored signed in the database. For every existing
value of C<hub>, there should be a I<hubname> key indicating the name that
belongs to the hub tab, including the preceding C<#> character.

  CREATE TABLE share (
    name TEXT NOT NULL PRIMARY KEY,
    path TEXT NOT NULL
  );

Stores the shared directories. C<name> is the virtual name, C<path> is the
absolute filesystem path obtained by C<realpath()>.

=head2 Hash data

  CREATE TABLE hashdata (
    root TEXT NOT NULL PRIMARY KEY,
    size INTEGER NOT NULL,
    tthl BLOB NOT NULL
  );

Unsurprisingly, this stores the hash data of shared files. C<root> is the TTH
root, encoded in base32. C<size> is the size of the file and C<tthl> is the TTH
data.

  CREATE TABLE hashfiles (
    id INTEGER PRIMARY KEY,
    filename TEXT NOT NULL UNIQUE,
    tth TEXT NOT NULL,
    lastmod INTEGER NOT NULL
  );

A mapping of I<files> to I<hashes>. The C<id> column is an alias for the SQLite
C<rowid>, and used internally in ncdc to speed up certain operations.
C<filename> is the absolute and canonical path to the file, as obtained from
C<realpath()>. C<tth> refers to C<hashdata (root)>, and C<lastmod> is the last
modification time, as a UNIX timestamp.

It is not uncommon to have multiple files with the same TTH. An row in
C<hashfiles> should B<always> have a corresponding row in C<hashdata>.  It is
possible to have an row in C<hashdata> with no row in C<hashfiles> referring to
it, or to have entries in C<hashfiles> that are not in a shared directory at
all. These are cleaned up with C</gc>.

=head2 Download queue

  CREATE TABLE dl (
    tth TEXT NOT NULL PRIMARY KEY,
    size INTEGER NOT NULL,
    dest TEXT NOT NULL,
    priority INTEGER NOT NULL DEFAULT 0,
    error INTEGER NOT NULL DEFAULT 0,
    error_msg TEXT,
    tthl BLOB
  );

Each row represents a file in the download queue. File list downloads are not
included. C<tth> is the base32-encoded TTH root of the file, C<size> the file
size, in bytes and C<dest> is the full destination path where the file will be
moved to after downloading. Possible values for C<priority> are defined in the
C<DLP_*> macros in dl.c. Possible C<error> values are defined in the C<DLE_*>
macros. C<error_msg> is NULL if there is no error. C<tthl> is the downloaded
TTH data, NULL if it hasn't been fetched yet.

  CREATE TABLE dl_users (
    tth TEXT NOT NULL,
    uid INTEGER NOT NULL,
    error INTEGER NOT NULL DEFAULT 0,
    error_msg TEXT,
    PRIMARY KEY(tth, uid)
  );

Stores the users from which a download queue item can be downloaded from.
C<tth> refers to C<dl (tth)>, C<uid> is the user id, stored as a 64-bit signed
integer but internally represented as an unsigned integer in ncdc. C<error> and
<error_msg> have the same meaning as for the C<dl_users> table, but obviously
represent errors that only affect the user rather than the file. (e.g. when the
file is not available from this user).

It is possible for a C<dl> row to have no corresponding rows in C<dl_users>,
but a C<dl_user> row must always refer to a row in C<dl>.
